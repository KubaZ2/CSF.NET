using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace CSF.Hosting
{
    /// <summary>
    ///     Represents a stream listener responsible for receiving and handling commands from less straight forward sources.
    /// </summary>
    /// <typeparam name="T">The framework to implement in this service.</typeparam>
    /// <typeparam name="TContext">The context that will be generated by the service.</typeparam>
    public abstract class CommandStreamListener<T, TContext> : ICommandStreamListener
        where T : CommandFramework where TContext : IContext
    {
        /// <summary>
        ///     Represents the framework responsible for executing commands.
        /// </summary>
        public T Framework { get; }

        /// <summary>
        ///     Represents the serviceprovider of the <see cref="IHost"/> executing this service.
        /// </summary>
        public IServiceProvider Services { get; }

        /// <summary>
        ///     Represents a <see cref="Microsoft.Extensions.Logging"/> counterpart to the internal <see cref="CommandFramework.Logger"/> and resolves through the intended stream at logging configuration.
        /// </summary>
        public ILogger<T> Logger { get; }

        /// <summary>
        ///     Creates a new <see cref="CommandStreamListener{T, TContext}"/> with provided services.
        /// </summary>
        /// <param name="framework"></param>
        /// <param name="collection"></param>
        /// <param name="logger"></param>
        public CommandStreamListener(T framework, IServiceProvider collection, ILogger<T> logger)
        {
            Framework = framework;

            Framework.Logger.Resolver = new LogResolver(async (x) => await LogAsync(x));
            Framework.CommandExecuted += CommandExecutedAsync;
            Framework.CommandRegistered += CommandRegisteredAsync;

            Services = collection;
            Logger = logger;
        }

        /// <inheritdoc/>
        public async Task StartAsync(CancellationToken cancellationToken)
        {
            await ResolveCommandsAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public async Task StopAsync(CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        ///     Resolves a command generated by <see cref="GetContextAsync(CancellationToken)"/>.
        /// </summary>
        /// <param name="cancellationToken">Indicates that the shutdown process should no longer be graceful.</param>
        /// <returns>An asynchronous <see cref="Task"/> with no return type.</returns>
        protected virtual async Task ResolveCommandsAsync(CancellationToken cancellationToken = default)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var context = await GetContextAsync(cancellationToken);

                await Framework.ExecuteCommandAsync(context).ConfigureAwait(false);
            }
        }

        /// <summary>
        ///     
        /// </summary>
        /// <param name="context"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        protected virtual Task CommandExecutedAsync(IContext context, IResult result)
        {
            if (!result.IsSuccess)
                Logger.LogError(result.Exception, "{}", result.ErrorMessage);

            return Task.CompletedTask;
        }

        /// <summary>
        ///     
        /// </summary>
        /// <param name="component"></param>
        /// <returns></returns>
        protected virtual Task CommandRegisteredAsync(IConditionalComponent component)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        ///     Mutates inbound logs from the <see cref="CommandFramework.Logger"/> into its <see cref="ILogger{TCategoryName}"/> counterpart.
        /// </summary>
        /// <param name="log">The log message to transform.</param>
        /// <returns>An asynchronous <see cref="Task"/> with no return type.</returns>
        protected virtual Task LogAsync(ILog log)
        {
            Logger.Log((Microsoft.Extensions.Logging.LogLevel)log.LogLevel, log.Exception, "{}", log.Value);

            return Task.CompletedTask;
        }

        /// <summary>
        ///     Fetches a <see cref="IContext"/> necessary for executing the command.
        /// </summary>
        /// <param name="cancellationToken">Indicates that the shutdown process should no longer be graceful.</param>
        /// <returns>An asynchronous <see cref="Task"/> holding the generated <see cref="IContext"/>.</returns>
        protected virtual async Task<TContext> GetContextAsync(CancellationToken cancellationToken = default)
        {
            var input = await GetInputStreamAsync(cancellationToken);

            return await GenerateContextAsync(input, cancellationToken);
        }

        /// <summary>
        ///     Consumes the input string and returns a <see cref="IContext"/> in return. The input string is raw, and should be used for prefix validation.
        /// </summary>
        /// <param name="input">The input string sourced from <see cref="GetInputStreamAsync(CancellationToken)"/>.</param>
        /// <param name="cancellationToken">Indicates that the shutdown process should no longer be graceful.</param>
        /// <returns>An asynchronous <see cref="Task"/> holding the generated <see cref="IContext"/></returns>
        protected abstract Task<TContext> GenerateContextAsync(string input, CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cancellationToken">Indicates that the shutdown process should no longer be graceful.</param>
        /// <returns>An asynchronous <see cref="Task"/> holding the input stream <see cref="String"/>.</returns>
        protected abstract Task<string> GetInputStreamAsync(CancellationToken cancellationToken = default);
    }
}
